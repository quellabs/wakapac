<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Boulderdash — single rAF loop</title>
    <style>
        :root { --cell: 26px; }
        body { margin:0; background:#0b1020; color:#e6e6e6; font:14px/1.4 system-ui,Segoe UI,Roboto,Arial; display:grid; place-items:center; min-height:100vh; }
        .wrap { width: min(95vw, 980px); }
        header { display:flex; gap:12px; align-items:center; justify-content:space-between; margin:20px 0; }
        header h1 { font:600 16px/1 system-ui; margin:0; letter-spacing:.3px; }
        .stats { display:flex; gap:12px; }
        .badge { background:#141a33; padding:6px 10px; border-radius:10px; }
        .grid { display:grid; grid-template-columns: repeat(var(--cols), var(--cell)); grid-auto-rows: var(--cell); gap:2px; background:#0b0f1f; padding:6px; border-radius:12px; box-shadow: 0 4px 24px rgba(0,0,0,.35) inset; }
        .cell { display:grid; place-items:center; font-weight:700; border-radius:4px; user-select:none; width:var(--cell); height:var(--cell); }
        .empty { background:#000; }
        .wall { background:#5e6b77; color:#1e2327; }
        .dirt { background:#7b4a20; color:#4c2b13; }
        .player { background:#ffd400; color:#000; }
        .boulder { background:#6a7680; color:#2a343b; }
        .diamond { background:#1be9ff; color:#004b52; }
        .exit { background:#11644d; color:#0a2e22; }
        .controls { margin-top:12px; display:flex; gap:8px; }
        button { background:#243056; color:#e6e6e6; border:none; padding:8px 12px; border-radius:10px; cursor:pointer; }
        button:active { transform: translateY(1px); }
    </style>
</head>
<body>
<div class="wrap">
    <header>
        <h1>Boulderdash</h1>
        <div class="stats">
            <div class="badge">Level: <span id="level">1</span></div>
            <div class="badge">Score: <span id="score">0</span></div>
            <div class="badge">Diamonds: <span id="diam">0</span>/<span id="need">0</span></div>
        </div>
    </header>
    <div id="grid" class="grid"></div>
    <div class="controls">
        <button id="restart">Restart</button>
        <button id="next">Next level</button>
    </div>
</div>

<script>
    // ==== config =====
    const BOARD_WIDTH = 28;
    const BOARD_HEIGHT = 18;
    const EMPTY=0, WALL=1, DIRT=2, PLAYER=3, BOULDER=4, DIAMOND=5, EXIT=6;
    const CLASSES = ['empty','wall','dirt','player','boulder','diamond','exit'];
    const GLYPHS = ['', '█','▒','☺','●','♦','⚑'];

    // ==== state =====
    const game = {
        grid: [],
        flat: [],
        playerX: 1,
        playerY: 1,
        diamonds: 0,
        need: 0,
        level: 1,
        score: 0,
        over: false,
        won: false,
        loopId: null,
        lastTick: 0,
        controlsReady: false
    };

    // ==== setup DOM =====
    const elGrid = document.getElementById('grid');
    const elLevel = document.getElementById('level');
    const elScore = document.getElementById('score');
    const elDiam = document.getElementById('diam');
    const elNeed = document.getElementById('need');

    function initGrid() {
        elGrid.style.setProperty('--cols', BOARD_WIDTH);
        const total = BOARD_WIDTH * BOARD_HEIGHT;
        if (game.flat.length !== total) game.flat = new Array(total).fill(EMPTY);
        elGrid.innerHTML = '';
        for (let i = 0; i < total; i++) {
            const cell = document.createElement('div');
            cell.className = 'cell empty';
            cell.textContent = '';
            elGrid.appendChild(cell);
        }
    }

    // ==== level generation =====
    function generateLevel(seed = game.level) {
        game.over = false; game.won = false; game.diamonds = 0; game.need = 0;
        game.grid = Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(EMPTY));
        // walls
        for (let x = 0; x < BOARD_WIDTH; x++) { game.grid[0][x] = WALL; game.grid[BOARD_HEIGHT-1][x] = WALL; }
        for (let y = 0; y < BOARD_HEIGHT; y++) { game.grid[y][0] = WALL; game.grid[y][BOARD_WIDTH-1] = WALL; }
        // sprinkle dirt and rocks and diamonds predictably
        let r = mulberry32(seed);
        for (let y = 1; y < BOARD_HEIGHT-1; y++) {
            for (let x = 1; x < BOARD_WIDTH-1; x++) {
                const v = r();
                if (v < 0.50) game.grid[y][x] = DIRT;
                else if (v < 0.66) game.grid[y][x] = BOULDER;
                else if (v < 0.74) { game.grid[y][x] = DIAMOND; game.need++; }
            }
        }
        // player and exit
        game.playerX = 2; game.playerY = 2; game.grid[game.playerY][game.playerX] = PLAYER;
        game.grid[BOARD_HEIGHT-2][BOARD_WIDTH-2] = EXIT;
        updateFlatFromGrid();
        updateHud();
    }

    function mulberry32(a){
        return function(){ let t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; };
    }

    // ==== transforms =====
    function updateFlatFromGrid() {
        const w = BOARD_WIDTH; const h = BOARD_HEIGHT; const total = w*h;
        if (game.flat.length !== total) game.flat = new Array(total);
        let i = 0;
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) { game.flat[i++] = game.grid[y][x]; }
        }
    }

    // ==== rendering =====
    function render() {
        const cells = elGrid.children; // HTMLCollection
        for (let i = 0; i < game.flat.length; i++) {
            const type = game.flat[i];
            const el = cells[i];
            const cls = CLASSES[type];
            if (!el.classList.contains(cls)) {
                el.className = `cell ${cls}`;
                el.textContent = GLYPHS[type];
            }
        }
    }

    function updateHud() {
        elLevel.textContent = String(game.level);
        elScore.textContent = String(game.score);
        elDiam.textContent = String(game.diamonds);
        elNeed.textContent = String(game.need);
    }

    // ==== movement =====
    function tryMove(dx, dy) {
        if (game.over || game.won) return;
        const nx = game.playerX + dx;
        const ny = game.playerY + dy;
        const target = game.grid[ny]?.[nx];
        if (target === undefined) return;
        if (target === WALL) return;

        if (target === BOULDER) {
            const bx = nx + dx; const by = ny + dy;
            if (dx !== 0 && dy === 0 && game.grid[by][bx] === EMPTY) {
                game.grid[by][bx] = BOULDER; // push
                game.grid[ny][nx] = EMPTY;
            } else { return; }
        }

        if (target === DIAMOND) { game.diamonds++; game.score += 10; }
        if (target === EXIT && game.diamonds >= game.need) { game.won = true; }

        game.grid[game.playerY][game.playerX] = EMPTY;
        game.playerX = nx; game.playerY = ny;
        game.grid[ny][nx] = PLAYER;
        updateFlatFromGrid();
    }

    // ==== physics =====
    function tickPhysics() {
        let changed = false;
        const w = BOARD_WIDTH; const h = BOARD_HEIGHT;
        const g2 = game.grid.map(row => row.slice());
        for (let y = h-2; y >= 1; y--) {
            for (let x = 1; x < w-1; x++) {
                if (game.grid[y][x] === BOULDER && game.grid[y+1][x] === EMPTY) {
                    g2[y][x] = EMPTY; g2[y+1][x] = BOULDER; changed = true;
                    if (y+1 === game.playerY && x === game.playerX) game.over = true;
                }
            }
        }
        if (changed) { game.grid = g2; updateFlatFromGrid(); }
    }

    // ==== loop =====
    function startLoop() {
        stopLoop();
        game.lastTick = performance.now();
        const step = (t) => {
            const elapsed = t - game.lastTick;
            if (elapsed >= 100) { // 10 Hz physics
                tickPhysics();
                game.lastTick = t;
            }
            render();
            game.loopId = requestAnimationFrame(step);
        };
        game.loopId = requestAnimationFrame(step);
    }

    function stopLoop() {
        if (game.loopId) { cancelAnimationFrame(game.loopId); game.loopId = null; }
    }

    // ==== controls =====
    function setupControls() {
        if (game.controlsReady) return; game.controlsReady = true;
        const map = new Map([
            ['arrowup', [0,-1]], ['w', [0,-1]],
            ['arrowdown', [0,1]], ['s', [0,1]],
            ['arrowleft', [-1,0]], ['a', [-1,0]],
            ['arrowright', [1,0]], ['d', [1,0]],
        ]);
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            const move = map.get(key);
            if (!move) return;
            e.preventDefault();
            tryMove(move[0], move[1]);
        });
        document.getElementById('restart').addEventListener('click', restartGame);
        document.getElementById('next').addEventListener('click', nextLevel);
    }

    function restartGame() {
        stopLoop();
        game.level = 1; game.score = 0;
        generateLevel();
        startLoop();
    }

    function nextLevel() {
        stopLoop();
        game.level += 1;
        game.score += 100;
        generateLevel();
        startLoop();
    }

    // ==== boot =====
    initGrid();
    setupControls();
    generateLevel();
    startLoop();
</script>
</body>
</html>
