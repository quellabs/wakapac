<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WakaPAC Spreadsheet</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&family=IBM+Plex+Sans:wght@400;500;600&display=swap');

        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

        :root {
            --cell-height: 28px;
            --cell-min-width: 100px;
            --header-bg: #f0f1f4;
            --header-bg-active: #d3e3fd;
            --header-text: #444746;
            --header-text-active: #0b57d0;
            --grid-border: #e1e3e6;
            --cell-bg: #fff;
            --select-border: #1a73e8;
            --select-fill: rgba(26, 115, 232, 0.08);
            --select-border-width: 3px;
            --edit-shadow: 0 1px 4px rgba(0,0,0,0.18), 0 0 0 2px var(--select-border);
            --formula-bar-height: 34px;
            --toolbar-height: 38px;
            --row-header-width: 46px;
            --font-body: 'IBM Plex Sans', -apple-system, sans-serif;
            --font-mono: 'IBM Plex Mono', monospace;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: var(--font-body),serif;
            font-size: 13px;
            color: #202124;
            background: #fff;
        }

        /* ── Toolbar ── */
        .toolbar {
            display: flex;
            align-items: center;
            height: var(--toolbar-height);
            padding: 0 8px;
            border-bottom: 1px solid var(--grid-border);
            background: #f8f9fa;
            gap: 2px;
        }
        .toolbar-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
            border: none;
            background: transparent;
            border-radius: 4px;
            cursor: pointer;
            color: #444;
            font-size: 14px;
            font-weight: 600;
        }
        .toolbar-btn:hover { background: #e8eaed; }
        .toolbar-sep { width: 1px; height: 20px; background: #dadce0; margin: 0 4px; }

        /* ── PAC container — wraps formula bar + grid ── */
        .spreadsheet-outer {
            display: flex;
            flex-direction: column;
            height: calc(100% - var(--toolbar-height) - 24px);
            outline: none;
        }

        /* ── Formula Bar (inside PAC container) ── */
        .formula-bar {
            display: flex;
            align-items: center;
            height: var(--formula-bar-height);
            min-height: var(--formula-bar-height);
            border-bottom: 1px solid var(--grid-border);
            background: #fff;
        }
        .cell-name-box {
            width: 80px;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            border-right: 1px solid var(--grid-border);
            font-family: var(--font-mono),serif;
            font-size: 12px;
            font-weight: 500;
            color: var(--header-text);
            background: var(--header-bg);
            user-select: none;
            flex-shrink: 0;
        }
        .formula-input {
            flex: 1;
            height: 100%;
            border: none;
            outline: none;
            padding: 0 10px;
            font-family: var(--font-mono),serif;
            font-size: 13px;
            color: #202124;
        }
        .formula-input:focus {
            background: #e8f0fe;
        }

        /* ── Grid scroll area ── */
        .grid-scroll-area {
            flex: 1;
            position: relative;
            overflow: auto;
        }

        /* ── Table ── */
        .grid-table {
            border-collapse: collapse;
            table-layout: fixed;
            user-select: none;
        }

        /* ── Corner header (top-left intersection) ── */
        .corner-header {
            position: sticky;
            top: 0;
            left: 0;
            z-index: 12;
            width: var(--row-header-width);
            min-width: var(--row-header-width);
            height: var(--cell-height);
            background: var(--header-bg);
            border-right: 1px solid var(--grid-border);
            border-bottom: 2px solid #c7c7cc;
        }

        /* ── Column headers (A, B, C, ...) ── */
        .col-header {
            position: sticky;
            top: 0;
            z-index: 10;
            height: var(--cell-height);
            min-width: var(--cell-min-width);
            background: var(--header-bg);
            border-right: 1px solid var(--grid-border);
            border-bottom: 2px solid #c7c7cc;
            text-align: center;
            font-size: 12px;
            font-weight: 500;
            color: var(--header-text);
            padding: 0 4px;
            vertical-align: middle;
            overflow: hidden;
        }
        .col-header.active {
            background: var(--header-bg-active);
            color: var(--header-text-active);
            font-weight: 600;
        }

        /* ── Row headers (1, 2, 3, ...) ── */
        .row-header {
            position: sticky;
            left: 0;
            z-index: 10;
            width: var(--row-header-width);
            min-width: var(--row-header-width);
            background: var(--header-bg);
            border-right: 1px solid var(--grid-border);
            border-bottom: 1px solid var(--grid-border);
            text-align: center;
            font-size: 12px;
            font-weight: 500;
            color: var(--header-text);
            vertical-align: middle;
            overflow: hidden;
        }
        .row-header.active {
            background: var(--header-bg-active);
            color: var(--header-text-active);
            font-weight: 600;
        }

        /* ── Data cells ── */
        td.cell {
            height: var(--cell-height);
            min-width: var(--cell-min-width);
            max-width: var(--cell-min-width);
            background: var(--cell-bg);
            border-right: 1px solid var(--grid-border);
            border-bottom: 1px solid var(--grid-border);
            padding: 0 5px;
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            vertical-align: middle;
            cursor: cell;
            position: relative;
        }
        td.cell.numeric { text-align: right; }

        /* ── Active cell selection overlay ── */
        .selection-highlight {
            position: absolute;
            pointer-events: none;
            z-index: 5;
            border: 2px solid var(--select-border);
            background: transparent;
            display: none;
        }
        .selection-highlight.visible { display: block; }

        /* ── Range selection overlay ── */
        .range-highlight {
            position: absolute;
            pointer-events: none;
            z-index: 4;
            background: var(--select-fill);
            border: 1px solid var(--select-border);
            display: none;
        }
        .range-highlight.visible { display: block; }

        /* ── Inline cell editor ── */
        .cell-editor {
            position: absolute;
            z-index: 20;
            display: none;
            border: none;
            outline: none;
            padding: 0 4px;
            font-family: var(--font-body),serif;
            font-size: 13px;
            color: #202124;
            background: #fff;
            box-shadow: var(--edit-shadow);
            min-width: var(--cell-min-width);
        }
        .cell-editor.active { display: block; }

        /* ── Status bar ── */
        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 24px;
            display: flex;
            align-items: center;
            padding: 0 12px;
            background: var(--header-bg);
            border-top: 1px solid var(--grid-border);
            font-size: 11px;
            color: #5f6368;
            z-index: 20;
            gap: 20px;
        }
        .status-bar .status-section {
            display: flex;
            align-items: center;
            gap: 4px;
        }
    </style>
</head>
<body>

<!-- Toolbar (static UI — no interaction wired yet) -->
<div class="toolbar">
    <button class="toolbar-btn" title="Bold"><b>B</b></button>
    <button class="toolbar-btn" title="Italic"><i>I</i></button>
    <button class="toolbar-btn" title="Underline"><u>U</u></button>
    <div class="toolbar-sep"></div>
    <button class="toolbar-btn" title="Align Left">≡</button>
    <button class="toolbar-btn" title="Align Center">≡</button>
    <button class="toolbar-btn" title="Align Right">≡</button>
    <div class="toolbar-sep"></div>
    <button class="toolbar-btn" title="Delete cell contents">⌫</button>
</div>

<!--
    Single PAC container. The formula bar, scrollable grid, cell editor,
    and selection overlays all live inside it. All interaction flows
    through msgProc — zero addEventListener calls.
-->
<div class="spreadsheet-outer" id="spreadsheet" data-pac-id="spreadsheet" tabindex="0">
    <div class="formula-bar">
        <div class="cell-name-box" id="cellNameBox">A1</div>
        <input class="formula-input" id="formulaInput" type="text" spellcheck="false" />
    </div>
    <div class="grid-scroll-area" id="gridScrollArea"></div>
</div>

<!-- Status bar (outside PAC — updated via direct DOM ref) -->
<div class="status-bar">
    <div class="status-section" id="statusInfo">Ready</div>
    <div class="status-section" id="statusAgg"></div>
</div>

<script src="../wakapac.js"></script>
<script>
    (function () {
        "use strict";

        // =====================================================================
        // CONSTANTS
        // =====================================================================

        /** Number of columns (A through Z) */
        const NUM_COLS = 26;

        /** Number of rows */
        const NUM_ROWS = 50;

        // =====================================================================
        // UTILITY FUNCTIONS
        // =====================================================================

        /**
         * Converts a zero-based column index to a letter (0 → "A", 25 → "Z").
         * @param {number} c - Column index.
         * @returns {string} Column letter.
         */
        function colToLetter(c) {
            return String.fromCharCode(65 + c);
        }

        /**
         * Builds a cell reference string from column and row indices.
         * @param {number} c - Zero-based column index.
         * @param {number} r - Zero-based row index.
         * @returns {string} Cell reference (e.g. "A1", "C12").
         */
        function cellRef(c, r) {
            return colToLetter(c) + (r + 1);
        }

        /**
         * Parses a cell reference string back into column/row indices.
         * @param {string} ref - Cell reference (e.g. "B3").
         * @returns {{ col: number, row: number }|null} Parsed result, or null if invalid.
         */
        function parseCellRef(ref) {
            const m = ref.match(/^([A-Z])(\d+)$/);

            if (!m) {
                return null;
            }

            return { col: m[1].charCodeAt(0) - 65, row: parseInt(m[2], 10) - 1 };
        }

        /**
         * Clamps a value to an inclusive range.
         * @param {number} v - Input value.
         * @param {number} lo - Minimum.
         * @param {number} hi - Maximum.
         * @returns {number} Clamped value.
         */
        function clamp(v, lo, hi) {
            return Math.max(lo, Math.min(hi, v));
        }

        /**
         * Tests whether a trimmed string represents a finite number.
         * @param {*} v - Value to test.
         * @returns {boolean} True if numeric.
         */
        function isNumeric(v) {
            return v !== "" && v !== null && !isNaN(v);
        }

        // =====================================================================
        // DOM CONSTRUCTION
        // =====================================================================

        /**
         * Builds the grid table, selection overlays, and cell editor inside
         * the given scroll container. Called once during init().
         * @param {HTMLElement} scrollArea - The scrollable container element.
         * @returns {{ table: HTMLTableElement, selDiv: HTMLDivElement, rangeDiv: HTMLDivElement, editor: HTMLInputElement }}
         */
        function buildGrid(scrollArea) {
            // Active cell selection overlay
            const selDiv = document.createElement("div");
            selDiv.className = "selection-highlight";
            scrollArea.appendChild(selDiv);

            // Range selection overlay (multi-cell)
            const rangeDiv = document.createElement("div");
            rangeDiv.className = "range-highlight";
            scrollArea.appendChild(rangeDiv);

            // Inline cell editor — a single <input> repositioned over the active cell
            const editor = document.createElement("input");
            editor.className = "cell-editor";
            editor.type = "text";
            editor.spellcheck = false;
            editor.setAttribute("autocomplete", "off");
            scrollArea.appendChild(editor);

            // Grid table
            const table = document.createElement("table");
            table.className = "grid-table";

            // Column headers
            const thead = document.createElement("thead");
            const headRow = document.createElement("tr");

            // Corner cell (intersection of row and column headers)
            const corner = document.createElement("th");
            corner.className = "corner-header";
            headRow.appendChild(corner);

            for (let c = 0; c < NUM_COLS; c++) {
                const th = document.createElement("th");
                th.className = "col-header";
                th.textContent = colToLetter(c);
                th.dataset.col = c;
                headRow.appendChild(th);
            }
            thead.appendChild(headRow);
            table.appendChild(thead);

            // Data rows with row headers
            const tbody = document.createElement("tbody");
            for (let r = 0; r < NUM_ROWS; r++) {
                const tr = document.createElement("tr");
                const rh = document.createElement("td");

                rh.className = "row-header";
                rh.textContent = r + 1;
                rh.dataset.row = r;
                tr.appendChild(rh);

                for (let c = 0; c < NUM_COLS; c++) {
                    const td = document.createElement("td");
                    td.className = "cell";
                    td.dataset.col = c;
                    td.dataset.row = r;
                    tr.appendChild(td);
                }

                tbody.appendChild(tr);
            }

            table.appendChild(tbody);
            scrollArea.appendChild(table);

            return { table, selDiv, rangeDiv, editor };
        }

        // =====================================================================
        // SPREADSHEET PAC COMPONENT
        // =====================================================================

        wakaPAC("#spreadsheet", {

            // -----------------------------------------------------------------
            // State
            // -----------------------------------------------------------------

            /** Sparse cell storage keyed by reference string (e.g. "A1") */
            cells: {},

            /** Active cell column (zero-based) */
            selCol: 0,

            /** Active cell row (zero-based) */
            selRow: 0,

            /** Range selection end column, or null when no range is active */
            selEndCol: null,

            /** Range selection end row, or null when no range is active */
            selEndRow: null,

            /** True when the inline cell editor is open */
            editing: false,

            /** True when the formula bar has focus and is being edited */
            _editingFormulaBar: false,

            /** True during a mouse-drag range selection (capture is held) */
            _dragging: false,

            /**
             * Guard flag: set after a drag-select ends with a real range,
             * so the subsequent MSG_LCLICK doesn't overwrite the selection.
             */
            _wasDrag: false,

            // -----------------------------------------------------------------
            // DOM references (assigned in init)
            // -----------------------------------------------------------------

            _table: null,
            _scrollArea: null,
            _selDiv: null,
            _rangeDiv: null,
            _editor: null,
            _formulaInput: null,
            _cellNameBox: null,
            _statusInfo: null,
            _statusAgg: null,

            // =================================================================
            // LIFECYCLE
            // =================================================================

            /**
             * Initializes the spreadsheet. Builds the grid DOM, stores element
             * references, renders the initial selection, and focuses the grid.
             * No addEventListener calls — all interaction routes through msgProc.
             */
            init() {
                this._scrollArea   = document.getElementById("gridScrollArea");
                const dom          = buildGrid(this._scrollArea);
                this._table        = dom.table;
                this._selDiv       = dom.selDiv;
                this._rangeDiv     = dom.rangeDiv;
                this._editor       = dom.editor;
                this._formulaInput = document.getElementById("formulaInput");
                this._cellNameBox  = document.getElementById("cellNameBox");
                this._statusInfo   = document.getElementById("statusInfo");
                this._statusAgg    = document.getElementById("statusAgg");

                this._updateSelectionUI();
                this._focusGrid();
            },

            // =================================================================
            // FOCUS HELPERS
            // =================================================================

            /**
             * Returns which sub-element currently holds keyboard focus.
             * @returns {"editor"|"formulaBar"|"grid"}
             */
            _focusedElement() {
                const active = document.activeElement;

                if (active === this._editor) {
                    return "editor";
                }

                if (active === this._formulaInput) {
                    return "formulaBar";
                }

                return "grid";
            },

            /**
             * Moves keyboard focus back to the grid container so that
             * subsequent keystrokes are handled as navigation/input.
             */
            _focusGrid() {
                document.getElementById("spreadsheet").focus();
            },

            // =================================================================
            // MESSAGE PROCEDURE
            // =================================================================

            /**
             * Central message handler. Every user interaction — mouse clicks,
             * keyboard input, focus changes, clipboard operations — arrives
             * here as a Win32-style message.
             * @param {CustomEvent} event - PAC event with .message, .wParam, .lParam, .originalEvent
             * @returns {false|undefined} Return false for cancellable messages to prevent default handling.
             */
            msgProc(event) {
                switch (event.message) {

                    // ---------------------------------------------------------
                    // Mouse: click selects a cell (or extends range with Shift)
                    // ---------------------------------------------------------
                    case wakaPAC.MSG_LCLICK: {
                        // Skip if we just finished a drag-select — the LCLICK
                        // fires after LBUTTONUP and would overwrite the range.
                        if (this._wasDrag) {
                            this._wasDrag = false;
                            break;
                        }

                        const hit = this._hitTest(event);

                        if (!hit) {
                            break;
                        }

                        // Commit any in-progress edits before changing selection
                        if (this.editing) {
                            this._commitEdit();
                        }

                        if (this._editingFormulaBar) {
                            this._commitFormulaBar();
                        }

                        // Shift-click extends the selection range
                        if (event.wParam & wakaPAC.MK_SHIFT) {
                            this.selEndCol = hit.col;
                            this.selEndRow = hit.row;
                        } else {
                            this.selCol = hit.col;
                            this.selRow = hit.row;
                            this.selEndCol = null;
                            this.selEndRow = null;
                        }

                        this._updateSelectionUI();
                        this._focusGrid();
                        return false;
                    }

                    // ---------------------------------------------------------
                    // Mouse: double-click enters edit mode on the clicked cell
                    // ---------------------------------------------------------
                    case wakaPAC.MSG_LBUTTONDBLCLK: {
                        const hit = this._hitTest(event);

                        if (!hit) {
                            break;
                        }

                        this.selCol = hit.col;
                        this.selRow = hit.row;
                        this.selEndCol = null;
                        this.selEndRow = null;

                        this._enterEditMode(null);

                        return false;
                    }

                    // ---------------------------------------------------------
                    // Mouse: button down starts a potential drag-select.
                    // Capture is acquired so MOUSEMOVE keeps arriving even
                    // if the cursor leaves the grid.
                    // ---------------------------------------------------------
                    case wakaPAC.MSG_LBUTTONDOWN: {
                        const hit = this._hitTest(event);

                        if (!hit) {
                            break;
                        }

                        if (this.editing) {
                            this._commitEdit();
                        }

                        if (this._editingFormulaBar) {
                            this._commitFormulaBar();
                        }

                        this.selCol = hit.col;
                        this.selRow = hit.row;
                        this.selEndCol = null;
                        this.selEndRow = null;
                        this._dragging = true;
                        wakaPAC.setCapture(this.pacId);
                        this._updateSelectionUI();
                        break;
                    }

                    // ---------------------------------------------------------
                    // Mouse: move extends the range during a drag-select
                    // ---------------------------------------------------------
                    case wakaPAC.MSG_MOUSEMOVE: {
                        if (!this._dragging) {
                            break;
                        }

                        const oe = event.originalEvent;

                        if (!oe) {
                            break;
                        }

                        const hit = this._hitTestCoords(oe.clientX, oe.clientY);

                        if (hit && (this.selEndCol !== hit.col || this.selEndRow !== hit.row)) {
                            this.selEndCol = hit.col;
                            this.selEndRow = hit.row;
                            this._updateSelectionUI();
                        }

                        break;
                    }

                    // ---------------------------------------------------------
                    // Mouse: button up ends the drag-select and releases capture
                    // ---------------------------------------------------------
                    case wakaPAC.MSG_LBUTTONUP: {
                        if (!this._dragging) {
                            break;
                        }

                        this._dragging = false;
                        wakaPAC.releaseCapture();

                        // Collapse range to single cell if start == end
                        if (this.selEndCol === this.selCol && this.selEndRow === this.selRow) {
                            this.selEndCol = null;
                            this.selEndRow = null;
                        }

                        // Flag so the subsequent LCLICK doesn't overwrite the range
                        if (this.selEndCol !== null || this.selEndRow !== null) {
                            this._wasDrag = true;
                        }

                        this._updateSelectionUI();
                        break;
                    }

                    // ---------------------------------------------------------
                    // Keyboard: all keydown events route through _handleKeyDown
                    // which dispatches based on which sub-element has focus
                    // ---------------------------------------------------------
                    case wakaPAC.MSG_KEYDOWN: {
                        this._handleKeyDown(event);
                        break;
                    }

                    // ---------------------------------------------------------
                    // Character input: when the grid is focused, typing a
                    // printable character opens the editor with that character
                    // ---------------------------------------------------------
                    case wakaPAC.MSG_CHAR: {
                        if (this._focusedElement() !== "grid") {
                            break;
                        }

                        if (event.wParam >= 32) {
                            this._enterEditMode(String.fromCharCode(event.wParam));
                        }

                        break;
                    }

                    // ---------------------------------------------------------
                    // Input complete: sync the formula bar while typing in
                    // the cell editor
                    // ---------------------------------------------------------
                    case wakaPAC.MSG_INPUT_COMPLETE: {
                        if (this._focusedElement() === "editor") {
                            this._formulaInput.value = this._editor.value;
                        }

                        break;
                    }

                    // ---------------------------------------------------------
                    // Focus gained: track when the formula bar becomes active
                    // ---------------------------------------------------------
                    case wakaPAC.MSG_SETFOCUS: {
                        if (event.target === this._formulaInput) {
                            this._editingFormulaBar = true;
                        }

                        break;
                    }

                    // ---------------------------------------------------------
                    // Focus lost: clear formula bar editing state
                    // ---------------------------------------------------------
                    case wakaPAC.MSG_KILLFOCUS: {
                        if (event.target === this._formulaInput) {
                            this._editingFormulaBar = false;
                        }

                        break;
                    }

                    // ---------------------------------------------------------
                    // Clipboard: copy selected cells as tab-delimited text
                    // ---------------------------------------------------------
                    case wakaPAC.MSG_COPY: {
                        this._handleCopy(event);
                        return false;
                    }

                    // ---------------------------------------------------------
                    // Clipboard: paste tab-delimited text into cells
                    // ---------------------------------------------------------
                    case wakaPAC.MSG_PASTE: {
                        this._handlePaste(event);
                        return false;
                    }
                }
            },

            // =================================================================
            // KEYBOARD HANDLER
            // =================================================================

            /**
             * Routes MSG_KEYDOWN based on which sub-element has focus.
             * The cell editor and formula bar each handle a small set of
             * commit/cancel keys; everything else is grid navigation.
             * @param {CustomEvent} event - The MSG_KEYDOWN PAC event.
             */
            _handleKeyDown(event) {
                const vk    = event.wParam;
                const shift = !!(event.lParam & wakaPAC.KM_SHIFT);
                const ctrl  = !!(event.lParam & wakaPAC.KM_CONTROL);
                const focus = this._focusedElement();

                // ── Cell editor is focused ──
                if (focus === "editor") {
                    switch (vk) {
                        case wakaPAC.VK_RETURN: {
                            this._commitEdit();
                            this._moveSelection(0, shift ? -1 : 1);
                            this._updateSelectionUI();
                            this._focusGrid();
                            event.preventDefault();
                            break;
                        }

                        case wakaPAC.VK_TAB: {
                            this._commitEdit();
                            this._moveSelection(shift ? -1 : 1, 0);
                            this._updateSelectionUI();
                            this._focusGrid();
                            event.preventDefault();
                            break;
                        }

                        case wakaPAC.VK_ESCAPE: {
                            this._cancelEdit();
                            this._focusGrid();
                            event.preventDefault();
                            break;
                        }
                    }
                    return;
                }

                // ── Formula bar is focused ──
                if (focus === "formulaBar") {
                    switch (vk) {
                        case wakaPAC.VK_RETURN: {
                            this._commitFormulaBar();
                            this._focusGrid();
                            event.preventDefault();
                            break;
                        }

                        case wakaPAC.VK_ESCAPE: {
                            this._formulaInput.value = this._getRawValue();
                            this._editingFormulaBar = false;
                            this._focusGrid();
                            event.preventDefault();
                            break;
                        }
                    }

                    return;
                }

                // ── Grid is focused — navigation ──
                switch (vk) {
                    case wakaPAC.VK_UP:
                    case wakaPAC.VK_DOWN:
                    case wakaPAC.VK_LEFT:
                    case wakaPAC.VK_RIGHT: {
                        const dc = vk === wakaPAC.VK_LEFT ? -1 : vk === wakaPAC.VK_RIGHT ? 1 : 0;
                        const dr = vk === wakaPAC.VK_UP   ? -1 : vk === wakaPAC.VK_DOWN  ? 1 : 0;

                        if (shift) {
                            // Extend range from current endpoint (or active cell if no range yet)
                            const ec = this.selEndCol !== null ? this.selEndCol : this.selCol;
                            const er = this.selEndRow !== null ? this.selEndRow : this.selRow;
                            this.selEndCol = clamp(ec + dc, 0, NUM_COLS - 1);
                            this.selEndRow = clamp(er + dr, 0, NUM_ROWS - 1);
                        } else {
                            this._moveSelection(dc, dr);
                        }

                        this._updateSelectionUI();
                        this._scrollToSelection();
                        event.preventDefault();
                        break;
                    }

                    case wakaPAC.VK_TAB: {
                        this._moveSelection(shift ? -1 : 1, 0);
                        this._updateSelectionUI();
                        this._scrollToSelection();
                        event.preventDefault();
                        break;
                    }

                    case wakaPAC.VK_RETURN: {
                        this._moveSelection(0, shift ? -1 : 1);
                        this._updateSelectionUI();
                        this._scrollToSelection();
                        event.preventDefault();
                        break;
                    }

                    case wakaPAC.VK_DELETE:
                    case wakaPAC.VK_BACK: {
                        this._clearSelectedCells();
                        event.preventDefault();
                        break;
                    }

                    case wakaPAC.VK_F2: {
                        this._enterEditMode(null);
                        event.preventDefault();
                        break;
                    }

                    case wakaPAC.VK_HOME: {
                        if (ctrl) {
                            this.selCol = 0;
                            this.selRow = 0;
                        } else {
                            this.selCol = 0;
                        }

                        this.selEndCol = null;
                        this.selEndRow = null;
                        this._updateSelectionUI();
                        this._scrollToSelection();
                        event.preventDefault();
                        break;
                    }

                    case wakaPAC.VK_END: {
                        if (ctrl) {
                            this.selCol = NUM_COLS - 1;
                            this.selRow = this._getLastUsedRow();
                        } else {
                            this.selCol = NUM_COLS - 1;
                        }

                        this.selEndCol = null;
                        this.selEndRow = null;
                        this._updateSelectionUI();
                        this._scrollToSelection();
                        event.preventDefault();
                        break;
                    }

                    case wakaPAC.VK_A: {
                        if (ctrl) {
                            this.selCol = 0;
                            this.selRow = 0;
                            this.selEndCol = NUM_COLS - 1;
                            this.selEndRow = NUM_ROWS - 1;
                            this._updateSelectionUI();
                            event.preventDefault();
                        }

                        break;
                    }
                }
            },

            // =================================================================
            // CELL DATA
            // =================================================================

            /**
             * Retrieves cell data for the given position.
             * @param {number} col - Column index.
             * @param {number} row - Row index.
             * @returns {{ raw: string, value: string|number }|null}
             */
            _getCellData(col, row) {
                return this.cells[cellRef(col, row)] || null;
            },

            /**
             * Stores or clears cell data and updates the DOM.
             * @param {number} col - Column index.
             * @param {number} row - Row index.
             * @param {string} raw - Raw input string (empty to clear).
             */
            _setCellData(col, row, raw) {
                const ref = cellRef(col, row);
                const trimmed = (raw || "").trim();

                if (trimmed === "") {
                    delete this.cells[ref];
                } else {
                    const value = isNumeric(trimmed) ? parseFloat(trimmed) : trimmed;
                    this.cells[ref] = { raw: trimmed, value: value };
                }

                this._renderCell(col, row);
                this._updateAggregates();
            },

            /**
             * Returns the raw input string for the currently selected cell.
             * @returns {string}
             */
            _getRawValue() {
                const data = this._getCellData(this.selCol, this.selRow);
                return data ? data.raw : "";
            },

            // =================================================================
            // CELL RENDERING
            // =================================================================

            /**
             * Finds the <td> DOM element for a given cell position.
             * @param {number} col - Column index.
             * @param {number} row - Row index.
             * @returns {HTMLTableCellElement|null}
             */
            _getCellElement(col, row) {
                return this._table.querySelector(`td.cell[data-col="${col}"][data-row="${row}"]`);
            },

            /**
             * Updates a single cell's displayed text and numeric alignment.
             * @param {number} col - Column index.
             * @param {number} row - Row index.
             */
            _renderCell(col, row) {
                const el = this._getCellElement(col, row);

                if (!el) {
                    return;
                }

                const data = this._getCellData(col, row);
                if (data) {
                    el.textContent = data.value;
                    el.classList.toggle("numeric", typeof data.value === "number");
                } else {
                    el.textContent = "";
                    el.classList.remove("numeric");
                }
            },

            // =================================================================
            // SELECTION MANAGEMENT
            // =================================================================

            /**
             * Moves the active cell by a column/row delta and clears any range.
             * @param {number} dc - Column delta (-1, 0, or 1).
             * @param {number} dr - Row delta (-1, 0, or 1).
             */
            _moveSelection(dc, dr) {
                this.selCol = clamp(this.selCol + dc, 0, NUM_COLS - 1);
                this.selRow = clamp(this.selRow + dr, 0, NUM_ROWS - 1);
                this.selEndCol = null;
                this.selEndRow = null;
            },

            /**
             * Computes the normalised bounding rectangle of the current selection.
             * Works for both single cells and multi-cell ranges.
             * @returns {{ minCol: number, maxCol: number, minRow: number, maxRow: number }}
             */
            _getSelectionRange() {
                const c2 = this.selEndCol !== null ? this.selEndCol : this.selCol;
                const r2 = this.selEndRow !== null ? this.selEndRow : this.selRow;

                return {
                    minCol: Math.min(this.selCol, c2), maxCol: Math.max(this.selCol, c2),
                    minRow: Math.min(this.selRow, r2), maxRow: Math.max(this.selRow, r2)
                };
            },

            /**
             * Tests whether the current selection spans more than one cell.
             * @returns {boolean}
             */
            _isRangeSelection() {
                return this.selEndCol !== null && this.selEndRow !== null &&
                    (this.selEndCol !== this.selCol || this.selEndRow !== this.selRow);
            },

            /**
             * Synchronizes all visual selection state: the active cell highlight,
             * the range overlay, the cell name box, the formula bar contents,
             * and the column/row header highlights.
             */
            _updateSelectionUI() {
                const sa = this._scrollArea;
                const activeCell = this._getCellElement(this.selCol, this.selRow);

                if (!activeCell) {
                    return;
                }

                // Update formula bar
                this._cellNameBox.textContent = cellRef(this.selCol, this.selRow);
                this._formulaInput.value = this._getRawValue();

                // Position the active cell highlight overlay
                const areaRect = sa.getBoundingClientRect();
                const cellRect = activeCell.getBoundingClientRect();
                const bw = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--select-border-width'));

                this._selDiv.style.left   = (cellRect.left - areaRect.left + sa.scrollLeft - bw) + "px";
                this._selDiv.style.top    = (cellRect.top - areaRect.top + sa.scrollTop - bw) + "px";
                this._selDiv.style.width  = (cellRect.width + bw) + "px";
                this._selDiv.style.height = (cellRect.height + bw) + "px";
                this._selDiv.classList.add("visible");

                // Position the range highlight overlay (multi-cell selection)
                if (this._isRangeSelection()) {
                    const range = this._getSelectionRange();
                    const tl = this._getCellElement(range.minCol, range.minRow);
                    const br = this._getCellElement(range.maxCol, range.maxRow);

                    if (tl && br) {
                        const tlR = tl.getBoundingClientRect();
                        const brR = br.getBoundingClientRect();
                        this._rangeDiv.style.left   = (tlR.left - areaRect.left + sa.scrollLeft) + "px";
                        this._rangeDiv.style.top    = (tlR.top - areaRect.top + sa.scrollTop) + "px";
                        this._rangeDiv.style.width  = (brR.right - tlR.left) + "px";
                        this._rangeDiv.style.height = (brR.bottom - tlR.top) + "px";
                        this._rangeDiv.classList.add("visible");
                    }
                } else {
                    this._rangeDiv.classList.remove("visible");
                }

                // Highlight active column and row headers
                this._table.querySelectorAll(".col-header.active, .row-header.active").forEach(
                    function (el) { el.classList.remove("active"); }
                );

                const range = this._getSelectionRange();

                for (let c = range.minCol; c <= range.maxCol; c++) {
                    const h = this._table.querySelector(`.col-header[data-col="${c}"]`);

                    if (h) {
                        h.classList.add("active");
                    }
                }

                for (let r = range.minRow; r <= range.maxRow; r++) {
                    const h = this._table.querySelector(`.row-header[data-row="${r}"]`);

                    if (h) {
                        h.classList.add("active");
                    }
                }

                this._updateAggregates();
            },

            /**
             * Scrolls the grid so the active cell is visible.
             */
            _scrollToSelection() {
                const cell = this._getCellElement(this.selCol, this.selRow);

                if (cell) {
                    cell.scrollIntoView({ block: "nearest", inline: "nearest" });
                }
            },

            // =================================================================
            // EDIT MODE
            // =================================================================

            /**
             * Opens the inline cell editor over the active cell.
             *
             * @param {string|null} initialChar - If non-null, the editor starts
             *     with this character (replacing cell contents). If null, the
             *     editor loads the cell's existing raw value (F2 / double-click).
             */
            _enterEditMode(initialChar) {
                this.editing = true;

                const cell = this._getCellElement(this.selCol, this.selRow);

                if (!cell) {
                    return;
                }

                // Position the editor input directly over the cell
                const sa = this._scrollArea;
                const areaRect = sa.getBoundingClientRect();
                const cellRect = cell.getBoundingClientRect();

                this._editor.style.left   = (cellRect.left - areaRect.left + sa.scrollLeft) + "px";
                this._editor.style.top    = (cellRect.top - areaRect.top + sa.scrollTop) + "px";
                this._editor.style.width  = cellRect.width + "px";
                this._editor.style.height = cellRect.height + "px";

                if (initialChar !== null) {
                    this._editor.value = initialChar;
                } else {
                    this._editor.value = this._getRawValue();
                }

                this._editor.classList.add("active");
                this._editor.focus();

                // Place cursor at end of text
                const len = this._editor.value.length;
                this._editor.setSelectionRange(len, len);

                this._formulaInput.value = this._editor.value;
                this._statusInfo.textContent = "Edit";
            },

            /**
             * Commits the cell editor's current value to the cell and closes it.
             */
            _commitEdit() {
                if (!this.editing) {
                    return;
                }

                this._editor.classList.remove("active");
                this.editing = false;
                this._setCellData(this.selCol, this.selRow, this._editor.value);
                this._statusInfo.textContent = "Ready";
            },

            /**
             * Discards the cell editor's value and closes it without saving.
             */
            _cancelEdit() {
                this._editor.classList.remove("active");
                this.editing = false;
                this._formulaInput.value = this._getRawValue();
                this._statusInfo.textContent = "Ready";
            },

            /**
             * Commits the formula bar's current value to the active cell.
             */
            _commitFormulaBar() {
                this._editingFormulaBar = false;
                this._setCellData(this.selCol, this.selRow, this._formulaInput.value);
                this._updateSelectionUI();
            },

            // =================================================================
            // HIT TESTING
            // =================================================================

            /**
             * Extracts cell coordinates from a PAC event's target element.
             * Returns null if the target is not a data cell.
             * @param {CustomEvent} event - PAC event.
             * @returns {{ col: number, row: number }|null}
             */
            _hitTest(event) {
                const target = event.target || event.originalEvent?.target;

                if (!target || !target.classList?.contains("cell")) {
                    return null;
                }

                return {
                    col: parseInt(target.dataset.col, 10),
                    row: parseInt(target.dataset.row, 10)
                };
            },

            /**
             * Resolves cell coordinates from viewport pixel coordinates.
             * Used during drag-select where the cursor may be over any element.
             * @param {number} clientX - Viewport X.
             * @param {number} clientY - Viewport Y.
             * @returns {{ col: number, row: number }|null}
             */
            _hitTestCoords(clientX, clientY) {
                const el = document.elementFromPoint(clientX, clientY);

                if (!el || !el.classList?.contains("cell")) {
                    return null;
                }

                return {
                    col: parseInt(el.dataset.col, 10),
                    row: parseInt(el.dataset.row, 10)
                };
            },

            // =================================================================
            // CLEAR / DELETE
            // =================================================================

            /**
             * Clears all cells within the current selection range.
             */
            _clearSelectedCells() {
                const range = this._getSelectionRange();

                for (let r = range.minRow; r <= range.maxRow; r++) {
                    for (let c = range.minCol; c <= range.maxCol; c++) {
                        this._setCellData(c, r, "");
                    }
                }

                this._updateSelectionUI();
            },

            // =================================================================
            // CLIPBOARD
            // =================================================================

            /**
             * Serializes the selected cells as tab-delimited text and writes
             * it to the clipboard via WakaPAC's copyData mechanism.
             * @param {CustomEvent} event - MSG_COPY event.
             */
            _handleCopy(event) {
                const range = this._getSelectionRange();
                const rows = [];

                for (let r = range.minRow; r <= range.maxRow; r++) {
                    const cols = [];

                    for (let c = range.minCol; c <= range.maxCol; c++) {
                        const data = this._getCellData(c, r);
                        cols.push(data ? data.raw : "");
                    }

                    rows.push(cols.join("\t"));
                }

                // WakaPAC reads copyData after msgProc returns and writes
                // it to the system clipboard
                event.detail.copyData = { "text/plain": rows.join("\n") };
            },

            /**
             * Parses tab-delimited clipboard text and writes it into cells
             * starting at the active cell position.
             * @param {CustomEvent} event - MSG_PASTE event.
             */
            _handlePaste(event) {
                const text = event.detail?.text;
                if (!text) {
                    return;
                }

                const rows = text.split(/\r?\n/);

                let r = this.selRow;

                for (let ri = 0; ri < rows.length && r < NUM_ROWS; ri++, r++) {
                    const cols = rows[ri].split("\t");

                    let c = this.selCol;

                    for (let ci = 0; ci < cols.length && c < NUM_COLS; ci++, c++) {
                        this._setCellData(c, r, cols[ci]);
                    }
                }

                this._updateSelectionUI();
            },

            // =================================================================
            // STATUS BAR AGGREGATES
            // =================================================================

            /**
             * Computes Sum / Avg / Count for numeric cells in the current
             * selection and updates the status bar. Only shown when two or
             * more numeric values are selected.
             */
            _updateAggregates() {
                const range = this._getSelectionRange();
                const values = [];

                for (let r = range.minRow; r <= range.maxRow; r++) {
                    for (let c = range.minCol; c <= range.maxCol; c++) {
                        const data = this._getCellData(c, r);

                        if (data && typeof data.value === "number") {
                            values.push(data.value);
                        }
                    }
                }

                if (values.length > 1) {
                    const sum = values.reduce((a, b) => a + b, 0);
                    this._statusAgg.textContent = `Sum: ${sum}   Avg: ${(sum / values.length).toFixed(2)}   Count: ${values.length}`;
                } else {
                    this._statusAgg.textContent = "";
                }
            },

            /**
             * Finds the last row that contains data. Used by Ctrl+End.
             * @returns {number} Zero-based row index.
             */
            _getLastUsedRow() {
                let maxRow = 0;

                Object.keys(this.cells).forEach(function (ref) {
                    const parsed = parseCellRef(ref);
                    if (parsed && parsed.row > maxRow) {
                        maxRow = parsed.row;
                    }
                });

                return maxRow;
            }
        });

    })();
</script>
</body>
</html>