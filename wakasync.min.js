!function(){"use strict";function e(){this._requestGroups=new Map,this.config={timeout:3e4,retries:0,retryDelay:1e3,validateStatus:e=>e.ok,responseType:"auto",headers:{"User-Agent":"WakaSync/1.0"}}}e.prototype={request(e,t={}){const r=this.validateAndNormalizeConfig(e,t);this._requestGroups||(this._requestGroups=new Map);const o=this.setupRequestState(r),s=r.timeout>0?this.createTimeoutPromise(r.timeout,o.controller):null,n=this.executeWithRetry(r,o).then(e=>this.processResponse(e,r,o)).then(e=>this.handleSuccess(e,r,o)).catch(e=>this.handleError(e,r));return(s?Promise.race([n,s]):n).finally(()=>{this.cleanupRequest(r.groupKey,o.token)})},get(e,t={}){return this.request(e,{...t,method:"GET"})},post(e,t,r={}){return this.request(e,{...r,method:"POST",data:t})},put(e,t,r={}){return this.request(e,{...r,method:"PUT",data:t})},delete(e,t={}){return this.request(e,{...t,method:"DELETE"})},patch(e,t,r={}){return this.request(e,{...r,method:"PATCH",data:t})},head(e,t={}){return this.request(e,{...t,method:"HEAD"})},create(t={}){const r=new e;return r.config={...this.config,...t},r},cancelGroup(e){if(!e||!this._requestGroups)return;const t=this._requestGroups.get(e);t&&t.controller&&!t.controller.signal.aborted&&t.controller.abort()},cancelAll(){this._requestGroups&&(this._requestGroups.forEach(e=>{e.controller&&!e.controller.signal.aborted&&e.controller.abort()}),this._requestGroups.clear())},getActiveRequestCount(){if(!this._requestGroups)return 0;let e=0;return this._requestGroups.forEach(t=>{t.controller&&!t.controller.signal.aborted&&e++}),e},validateAndNormalizeConfig(e,t){if(!e||"string"!=typeof e)throw new Error("URL must be a non-empty string");const r={...this.config,...t};this.validateCallbacks(r),this.validateAbortControls(r);const{method:o,body:s}=this.normalizeMethodAndBody(r),n=this.buildHeaders(r,s),a=this.buildFetchPassthrough(r);return{url:e,method:o,headers:n,body:s,groupKey:r.groupKey??(r.latestOnly?this.getGroupKeyFromUrl(e,r):null),fetchOptions:a,timeout:Math.max(0,parseInt(r.timeout)||3e4),ignoreAbort:!!r.ignoreAbort,validateStatus:r.validateStatus||(e=>e.ok),responseType:r.responseType||"auto",onSuccess:r.onSuccess,onError:r.onError,onProgress:r.onProgress,abortController:r.abortController,retries:Math.max(0,parseInt(r.retries)||0),retryDelay:Math.max(0,parseInt(r.retryDelay)||1e3),shouldRetry:r.shouldRetry}},validateCallbacks(e){[["onSuccess",e.onSuccess],["onError",e.onError],["onProgress",e.onProgress],["urlNormalizer",e.urlNormalizer],["shouldRetry",e.shouldRetry]].forEach(([e,t])=>{if(t&&"function"!=typeof t)throw new Error(`${e} must be a function`)})},validateAbortControls(e){if(e.abortController&&"function"!=typeof e.abortController.abort)throw new Error("abortController must have an abort method")},normalizeMethodAndBody(e){const t=(e.method||"GET").toUpperCase();if(["GET","HEAD"].includes(t))return e.data,{method:t};let r;return void 0!==e.data&&(r="string"==typeof e.data||e.data instanceof FormData||e.data instanceof Blob||e.data instanceof ArrayBuffer?e.data:JSON.stringify(e.data)),{method:t,body:r}},buildHeaders(e,t){const r=new Headers;r.set("X-WakaSync-Request","true"),void 0!==t&&(t instanceof FormData||(t instanceof Blob||t instanceof ArrayBuffer?r.set("Content-Type","application/octet-stream"):"string"==typeof t?r.set("Content-Type","text/plain; charset=utf-8"):r.set("Content-Type","application/json; charset=utf-8")));const o=e.headers||{};return Object.keys(o).some(e=>"accept"===e.toLowerCase())||r.set("Accept","application/json, text/plain, */*"),Object.entries(o).forEach(([e,t])=>{r.set(e,t)}),r},buildFetchPassthrough(e){const t={};return["credentials","mode","cache","redirect","referrer","referrerPolicy","integrity","keepalive","priority"].forEach(r=>{void 0!==e[r]&&(t[r]=e[r])}),t},getGroupKeyFromUrl(e,t){return t.urlNormalizer?t.urlNormalizer(e):this.normalizeUrlForGrouping(e,t.baseUrl)},normalizeUrlForGrouping(e,t){try{let r;r="undefined"!=typeof globalThis&&globalThis.location?t||globalThis.location.origin:t||"http://localhost";const o=new URL(e,r);o.hash="";const s=new URLSearchParams(o.search),n=new URLSearchParams;return[...s.keys()].sort().forEach(e=>{s.getAll(e).sort().forEach(t=>{n.append(e,t)})}),o.search=n.toString(),o.toString()}catch{return e}},setupRequestState(e){const t=this.createCombinedController(e);let r=0;if(e.groupKey){const o=this._requestGroups.get(e.groupKey);o?(o.controller&&!o.controller.signal.aborted&&o.controller.abort(),r=o.token+1):r=1,this._requestGroups.set(e.groupKey,{token:r,controller:t})}return{token:r,controller:t,groupKey:e.groupKey}},createCombinedController:e=>e.abortController?e.abortController:new AbortController,createTimeoutPromise(e,t){return new Promise((r,o)=>{if(t.signal.aborted)return void o(this.createTaggedCancellationError("Request was cancelled before timeout","timeout"));const s=setTimeout(()=>{t.signal.aborted||(t.abort(),o(this.createTaggedCancellationError(`Request timeout after ${e}ms`,"timeout")))},e);t.signal.addEventListener("abort",()=>clearTimeout(s),{once:!0})})},async executeWithRetry(e,t){let r;const o=e.retries+1;for(let s=1;s<=o;s++)try{return await this.executeFetch(e,t)}catch(t){if(r=t,this.isCancellationError(t))throw t;if(!(e.shouldRetry?e.shouldRetry(t,s,o):this.defaultShouldRetry(t,s,o))||s===o)throw t;e.retryDelay>0&&await this.delay(e.retryDelay)}throw r},defaultShouldRetry(e,t,r){return!(t>=r||this.isCancellationError(e)||!e.network&&!(e.response&&e.response.status>=500)&&(!e.response||429!==e.response.status))},delay:e=>new Promise(t=>setTimeout(t,e)),async executeFetch(e,t){if(t.controller.signal.aborted)throw this.createTaggedCancellationError("Request was cancelled before execution","cancelled");const r={method:e.method,headers:e.headers,body:e.body,signal:t.controller.signal,...e.fetchOptions};try{return await fetch(e.url,r)}catch(e){throw"TypeError"!==e.name||t.controller.signal.aborted||(e.network=!0),e}},async processResponse(e,t,r){if(r.controller.signal.aborted)throw this.createTaggedCancellationError("Request was cancelled during processing","cancelled");if(!t.validateStatus(e)){const t=await this.safeGetResponseText(e),r=new Error(`HTTP ${e.status}: ${e.statusText}${t?` - ${t}`:""}`);throw r.response=e,r}if("HEAD"!==t.method&&![204,205,304].includes(e.status))return this.parseResponse(e,t.responseType)},async parseResponse(e,t){try{switch(t){case"json":return await e.json();case"text":return await e.text();case"blob":return await e.blob();case"response":return e;default:return this.autoParseResponse(e)}}catch(e){throw new Error(`Failed to parse response as ${t}: ${e.message}`)}},async autoParseResponse(e){const t=e.headers.get("content-type")||"";if("0"!==e.headers.get("content-length")){if(/json|\+json/i.test(t)){const t=await e.text();return t.trim()?JSON.parse(t):void 0}return/^text\//i.test(t)?e.text():e.blob()}},async safeGetResponseText(e){try{if(e.bodyUsed)return null;const t=e.clone();return(await t.text()).substring(0,200)}catch{return null}},handleSuccess(e,t,r){if(r.controller.signal.aborted){if(t.ignoreAbort)return;throw this.createTaggedCancellationError("Request was cancelled","cancelled")}if(t.onSuccess)try{t.onSuccess(e)}catch(e){}return e},handleError(e,t){if(!this.isCancellationError(e)||!t.ignoreAbort){if(t.onError)try{t.onError(e)}catch(e){}throw e}},createTaggedCancellationError(e,t){const r=new Error(e);return r.name="CancellationError",r.cancellationType=t,r},isCancellationError:e=>"AbortError"===e.name||"CancellationError"===e.name||!!e.cancellationType&&["timeout","cancelled","superseded"].includes(e.cancellationType),cleanupRequest(e,t){if(!e)return;const r=this._requestGroups.get(e);r&&(r.token===t||r.token<t)&&this._requestGroups.delete(e)}};const t=new e;"undefined"!=typeof window&&(window.WakaSync=e,window.wakaSync=t)}();